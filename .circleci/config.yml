version: 2.1

orbs:
  aws-eks: circleci/aws-eks@1.1.0
  kubernetes: circleci/kubernetes@0.12.0
  aws-cli: circleci/aws-cli@2.0.3


commands:
  destroy_environ:
    description: destroy deployment ennvironment
    parameters:
      awsConfigStatus:
        type: enum
        default: "yes"
        enum: ["yes", "no"]
      clusteNetworkStackName: 
        type: string 
      clusterCoreStackName:
        type: string 
    steps:
      - run:
          name: destroy deployment environment
          when: on_fail
          command: |
            awsStatus=<<parameters.awsConfigStatus>>
            if [ "$awsStatus" == "no" ];
              then
                # TODO: install awscli
                exit 1;
            fi;
            
            NETWSTACK=<< parameters.clusteNetworkStackName >>;
            CLUSTSTACK=<< parameters.clusterCoreStackName >>;
            STACKNAMES=( "$CLUSTSTACK"  "$NETWSTACK" )
            for name in ${STACKNAMES[@]} ; do 
              stack=$(aws cloudformation list-stacks --query "StackSummaries[?(@.StackName=='$name')]")
              if  [[ -n $( echo "$stack" | grep -E "$name"  ) ]]; then 
                echo -e "DELETING STACK: $name\n";
                aws cloudformation delete-stack --stack-name $name --region "${AWS_DEFAULT_REGION}";
              fi;  
            done;         

  cache_handle:
    description: helper command to store or retrieve values from MemoStash
    parameters:
      operation:
        type: enum
        default: 'GET'
        enum: ['GET', 'PUT']
      key:
        type: string 
      value: 
        type: string
    steps:
      - run:
          command: |
            OPER=<< parameters.operation >>;
            KEY=<< parameters.key >>;
            if [ "$OPER" == "GET" ]; then
              curl -H "token: ${MEM_ST_TOKEN}" --request GET https://api.memstash.io/values/$KEY
            else
              VALUE=<< parameters.value >>
              curl -H "Content-Type: text/plain" -H "token: ${MEM_ST_TOKEN}" --request PUT --data "$VALUE" https://api.memstash.io/values/$KEY;
            fi;

  setup_awscli:
    steps:
      - aws-cli/install
      - run:
          name: configure aws profile
          command: |
            aws configure set aws_secret_access_key ${AWS_SECRET_ACCESS_KEY}
            aws configure set aws_access_key_id ${AWS_ACCESS_KEY_ID}
            aws configure set aws_default_region ${AWS_DEFAULT_REGION}

jobs:
  build_app:
    description: Analyze backend source code
    docker:
      - image: circleci/python:3.8.4
    steps:
      - checkout
      - run:
          name: create environment to run code analyze
          command: |
            # require virtural environ 
            make setup
      - run:
          name: install dependencies
          command: |
            # install deps
            make install
      - run:
          name: run code lints
          command: |
            # format the source code 
            make lint
      - save_cache:
          paths:
            - ".venv"
          key: deps-Pipfile.lock
    
  coverage_tests:
    docker:
      - image: circleci/python:3.8.4
      - image: circleci/postgres:9.6.16
        environment:
          POSTGRES_USERNAME: postgres
          POSRGRES_PASSWORD: password
          POSTGRES_PORT: 5432
    # working_directory: ./
    environment:
      POSTGRES_USERNAME: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_HOSTNAME: localhost
      FLASK_APP: "openhcs/app.py"
    steps:
      - checkout
      - restore_cache:
          keys: 
            - deps-Pipfile.lock
      - run:
          name: Install dependencies
          command: |
            sudo apt update 
            sudo apt-get install -y postgresql-client --fix-missing
            # make install    
      - run:
          name: run local database migrations tests
          command: |
            pipenv run flask populate --tables=all; 
            psql -h ${POSTGRES_HOSTNAME} -U ${POSTGRES_USERNAME} -d postgres -w -c "\l"
            psql -h ${POSTGRES_HOSTNAME} -U ${POSTGRES_USERNAME} -d postgres -w -c "\dt"
            # make migrations
      - run:
          name: run code coverage tests 
          command: |
            # pass IF coverage > 70%
            make test

  build_docker_image:
    description: build the docker image from code
    machine: 
      image: ubuntu-2004:202107-02
    environment:
      OPENHCS_IMAGE_TAG: "${DOCKER_ID}/openhcs:latest"
    steps:
      - checkout
      - run:
          name: login to docker hub
          command: docker login --username ${DOCKER_ID} --password ${DOCKER_PASSWORD}
      - run:
          name: build the openhcs docker image
          command: |
            docker build . -t openhcs:latest
            export docker_path=${DOCKER_ID}/openhcs:latest
            docker tag openhcs:latest $docker_path
      - run:
          name: push openhcs image to docker hub
          command: |
            export docker_path=${DOCKER_ID}/openhcs:latest
            docker push $docker_path

  create_cluster_infrastructure:
    description: provision the cluster infrastructue 
    docker: 
      - image: cimg/base:stable
      # - image: amazon/aws-cli
    environment:
      CLUSTER_IAC_STACK_NAME: openhcs-iacode
    steps:
      - checkout
      - setup_awscli
      - run:
          name: create the network infrastructure
          working_directory: ".circleci/deployment/IaC"
          no_output_timeout: 20m
          command: |
            aws cloudformation deploy --stack-name ${CLUSTER_IAC_STACK_NAME} \
            --template-file clusterIaC.yml --region "${AWS_DEFAULT_REGION}" \
            --capabilities "CAPABILITY_IAM" "CAPABILITY_NAMED_IAM" \
            --profile default 
            
      # - cache_handle:
      #     operation: 'PUT'
      #     key: "CLUSTER_IAC_STACKNAME"
      #     value: ${CLUSTER_IAC_STACK_NAME}
      - destroy_environ:
          awsConfigStatus: "yes"
          clusteNetworkStackName: ${CLUSTER_IAC_STACK_NAME} 
          clusterCoreStackName: ''  

  create_cluster_core:
    description: create cluster control plane and workload node 
    docker:
      - image: cimg/base:stable
    environment:
      CLUSTER_STACK_NAME: openhcs-cls-core
      CLUSTER_NAME: openhcs
    steps:
      - checkout
      - setup_awscli
      - aws-eks/install-eksctl
      - run:
          name: create cluster and managed node groups
          working_directory: ".circleci/deployment/IaC"
          no_output_timeout: 20m
          command: |
            aws cloudformation deploy --stack-name ${CLUSTER_STACK_NAME} \
            --template-file clusterCore.yml --region ${AWS_DEFAULT_REGION} \
            --capabilities "CAPABILITY_IAM" "CAPABILITY_NAMED_IAM" \
            --parameter-overrides ClusterIaCStackName="openhcs-iacode" --profile default 
            
      - run:
          name: enable cluster logging types 
          command: |
            eksctl utils update-cluster-logging --cluster $CLUSTER_NAME  --enable-types=all --approve
      # - cache_handle:
      #     operation: 'PUT'
      #     key: "CLUSTER_STACK_NAME"
      #     value: $CLUSTER_STACK_NAME
      - destroy_environ:
          awsConfigStatus: "yes"
          clusteNetworkStackName: openhcs-iacode
          clusterCoreStackName: openhcs-cluster

  configure_cluster_core:
    description: configure cluster kubernetes 
    docker:
      # replace with your preferred image
      - image: cimg/base:stable
    environment:
      CLUSTER_NAME: openhcs
      CLUSTER_STACK_NAME: openhcs-cls-core
      CLUSTER_IAC_STACK_NAME: openhcs-iacode
      GREEN_SERVER_PORT: 443
    steps:
      - checkout
      - setup_awscli
      - kubernetes/install-kubectl:
          kubectl-version: latest
      - aws-eks/install-eksctl
      - aws-eks/update-kubeconfig-with-authenticator: 
          aws-region: ${AWS_DEFAULT_REGION}
          cluster-name: ${CLUSTER_NAME}
      - run:
          name: test kubernetes config file 
          command: |
            SVCS=$(kubectl  get services -n kube-system -o json )
            # Abort deployment if empty 
            if [ "$SVCS" = *"kube-system"* ]; then 
              echo "Cofigured Successfully";
              ls ~/.kube
            else
              exit 1;
            fi;
      - run:
          name: create services for app deployment
          working_directory: ".circleci/deployment/K8s/xbin"  
          command: |
            # create services
            ./services-init.sh $GREEN_SERVER_PORT;
      - run:
          name: create alb ingresses
          working_directory: ".circleci/deployment/K8s"
          command: |
            kubectl apply -f ../ingresses.yml
            sleep 10s
            kubectl get ig -n default
      - run:
          name: create configmaps and secretes 
          working_directory: ".circleci/deployment/K8s"
          command: |
            # create configmaps
            chmod +x ./xbin/configs-init.sh
            ./xbin/configs-init.sh .configmaps.yml
            # create secrets
            chmod +x ./xbin/secrets-init.sh
            ./xbin/secrets-init.sh secrets.yml

            kube get secrets -n default
      # persist the kubeconfig file 
      - persist_to_workspace:
          root: ~/
          paths:
            - ".kube"
      - destroy_environ:
          awsConfigStatus: "yes"
          clusteNetworkStackName: ${CLUSTER_IAC_STACK_NAME} 
          clusterCoreStackName: ${CLUSTER_STACK_NAME}
    
  make_k8s_deployments:
    description: >- 
      Deploy API server kubernetes in staging environment, and green context (IF three is None already running). 
      Then, transition to  production blue context (IF pass smoke test), within the default namespace.
    docker:
      - image: cimg/base:stable
    environment:
      ENVIRON: staging     # environ for the deployment
      SERVER_PORT: 80      # web server port number
      VERSION: 1          # deployment version
    steps:
      - checkout
      - attach_workspace:
          at: ~/
      - kubernetes/install-kubectl:
          kubectl-version: latest 
      - run:
          name: make deployment
          working_directory: ".circleci/deployment/K8s"
          command: |
            OPENHCS_IMAGE="${DOCKER_ID}/openhcs:latest"   # docker image
            chmod +x xbin/deploy-init.sh
            # execute the deployment of app in the staging environment
            xbin/deploy-init.sh $ENVIRON $SERVER_PORT $VERSION $OPENHCS_IMAGE
            DPYS=$(kubectl get deployments -n default -l tier=backend,environ='$ENVIRON',context=green -o jsonpath="{.items[*]}")
            watch -p -n 3 $DPY
      - run: 
          name: test deployed app running as expected
          working_directory: ".circleci/deployment/K8s"
          command: |
            # get the url for staging app
            URL=http://$(kubernetes get services -n default -l environ='$ENVIRON',app='openhcs-green' -o jsonpath="{.items[0].status.loadbalancer.ingress[0].ip}"):"${SERVER_PORT}"
            
            # make request using the url
            REPONSE=$(curl $URL )
            
            # check if status if ok in the returned response 
            if [[ "$RESPONSE" = *"ok"* ]]; then 
              # Promote to production
              chmod +x xbin/promote-to-production.sh 
              xbin/promote-to-production $SERVER_PORT $OPENHCS_IMAGE "./deployments.yml"
              wath -p -n 3 -x kubectl get deploymens/openhcs-blue;
            fi;
            
      - run:
          name: check in production status 
          command: |
            # get the url for staging app
            URL=http://$(kubernetes get services -n default -l environ='$ENVIRON',app='openhcs-green' -o jsonpath="{.items[0].status.loadbalancer.ingress[0].ip}"):"${SERVER_PORT}"
                      
            # make request using the url
            REPONSE=$(curl $URL )
            STAGING=$(kubectl get deployments -l environ='staging',context='green' -o jsonpath="{.items[0].metadata.labels.name}" 
            # test in production app status is ok
            if [[ "$RESPONSE" = *"ok"* ]]; then 
              # eliminate the in staging deployment
              kubectl delete deployment $STAGING --namespace default
              wath -p -n 3 -x kubectl get deploymens;
            else
              # eliminate in production app if status is NOT ok, and exit with failure
            fi; 
          
          
  make_migrations:
    docker:
      - image: circleci/python:3.8.4
    environment:
      FLASK_APP: "openhcs/app.py"
    steps:
      - checkout
      - restore_cache:
          keys: 
            - deps-Pipfile.lock
      - run:
          name: prepare the required variables for migrations 
          command: |
            cat > ./openhcs/.env \<< EOF 
            FLASK_APP=openhcs/app.py
            FLASK_ENV=production
            PSQL_DB_PROFILES=${PSQL_DB_PROFILES}
            PSQL_DB_SCHEDULES=${PSQL_DB_SCHEDULES}
            PSQL_DB_SUBSCRIBERS=${PSQL_DB_SUBSCRIBERS}
            PSQL_DB_BOOKING=${PSQL_DB_BOOKING}
            PSQL_HOSTNAME=${PSQL_HOSTNAME}
            PSQL_PASSWORD=${PSQL_PASSWORD}
            PSQL_USERNAME=${PSQL_USERNAME}
            EOF
            
      - run:
          name: run migrations
          command: |
            # execute flask-migrate
            make migrations

workflows:
  OpenHeathCare CICD:
    jobs:
      - build_app
      - coverage_tests:
          requires:
            - "build_app"
      - review_codebase:
          type: approval
          requires:
            - coverage_tests
      - make_migrations:
          context: THEOPENHCS
          requires:
            - "coverage_tests"
            # - "review_codebase"
          filters:
            branches:
              only: [main]
      - build_docker_image:
          context: THEOPENHCS
          filters:
            branches:
              only: [main]
          requires:
            - coverage_tests
            - make_migrations
      - review_built_image:
          requires: [build_docker_image]
          type: approval
      
      - create_cluster_infrastructure:
          context: THEOPENHCS
          pre-steps:
            - run:
                name: Notify administrator
                command: |
                  echo  "Send notification from here"
          requires:
            # - review_built_image
            - build_docker_image
          filters:
            branches:
              only: [main]

      - create_cluster_core:
          context: THEOPENHCS
          requires:
            - create_cluster_infrastructure

      - configure_cluster_core:
          context: THEOPENHCS
          requires:
            - "create_cluster_core"
          filters:
            branches:
              only: [main]
          post-steps:
            - run:
                name: Notify administrator
                command: |
                  echo "Send notification from here"
      - make_k8s_deployments:
          context: THEOPENHCS
          requires:
            - "configure_cluster_core"