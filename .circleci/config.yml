version: 2.1

orbs:
  aws-eks: circleci/aws-eks@1.1.0
  kubernetes: circleci/kubernetes@0.12.0
  aws-cli: circleci/aws-cli@2.0.3


commands:
  destroy_environ:
    description: destroy deployment ennvironment
    parameters:
      awsConfigStatus:
        type: enum
        default: "yes"
        enum: ["yes", "no"]
      clusteNetworkStackName: 
        type: string 
      clusterCoreStackName:
        type: string 
    steps:
      - run:
          name: destroy deployment environment
          when: on_fail
          command: |
            awsStatus=<<parameters.awsConfigStatus>>
            if [ "$awsStatus" == "no" ];
              then
                # DO: install awscli
                exit 1;
            fi;
            
            CLUSTER_CORE_STACK=<< parameters.clusterCoreStackName >>;
            if [[ -z "$CLUSTER_CORE_STACK" ]]; then 
              aws cloudformation delete-stack --stack-name $CLUSTER_CORE_STACK --region "${AWS_DEFAULT_REGION}" ;   
            fi;
      - run:
          name: delete elbs
          when: on_fail
          command: |
             # get all alb dns name from config maps 
              export ELBS=($(aws elbv2 describe-load-balancers --output text  --query "LoadBalancerDescriptions[].LoadBalancerName" ) )
              for elb in ${ELBS[@]}; do 
                aws elbv2 delete-load-balancer --load-balancer-name $elb --profile default;
              done; 
      - run:
          name: delete VPC and Subnets and remaining stack resources
          when: on_fail
          command: |
            # echo -e "DELETING STACK: $name\n";
            CLUSTER_NETW_STACK=<< parameters.clusteNetworkStackName >>;
            if [[ -z "$CLUSTER_NETW_STACK" ]]; then 
              aws cloudformation delete-stack --stack-name $CLUSTER_NETW_STACK --region "${AWS_DEFAULT_REGION}" ;   
            fi;
      

  cache_handle:
    description: helper command to store or retrieve values from MemoStash
    parameters:
      operation:
        type: enum
        default: 'GET'
        enum: ['GET', 'PUT']
      key:
        type: string 
      value: 
        type: string
    steps:
      - run:
          command: |
            OPER=<< parameters.operation >>;
            KEY=<< parameters.key >>;
            if [ "$OPER" == "GET" ]; then
              curl -H "token: ${MEM_ST_TOKEN}" --request GET https://api.memstash.io/values/$KEY
            else
              VALUE=<< parameters.value >>
              curl -H "Content-Type: text/plain" -H "token: ${MEM_ST_TOKEN}" --request PUT --data "$VALUE" https://api.memstash.io/values/$KEY;
            fi;

  setup_awscli:
    steps:
      - aws-cli/install
      - run:
          name: configure aws profile
          command: |
            aws configure set aws_secret_access_key ${AWS_SECRET_ACCESS_KEY}
            aws configure set aws_access_key_id ${AWS_ACCESS_KEY_ID}
            aws configure set aws_default_region ${AWS_DEFAULT_REGION}

  install_envsubs:
    steps:
      - run:
          name: update apt and install gettext-base(envSUBST)
          command: |
            # sudo apt-get update -y
            sudo apt install -y gettext-base --fix-missing

  delete_network_infra_stack:
    steps:
      - run:
          name: delete loadbalancers deleting VPC and Subnets
          command: |
            # get all alb dns name from config maps 
            export ELBS=($(aws elbv2 describe-load-balancers --output text  --query "LoadBalancerDescriptions[].LoadBalancerName" ) )
            for elb in ${ELBS[@]}; do 
              aws elbv2 delete-load-balancer --load-balancer-name $elb --profile default;
            done;
      - run:
          name: delete VPC and Subnets 
          command: |
            # echo -e "DELETING STACK: $name\n";
            aws cloudformation delete-stack --stack-name $CLUSTER_IAC_STACK_NAME --region "${AWS_DEFAULT_REGION}" ;


jobs:
  build_app:
    description: Analyze backend source code
    docker:
      - image: circleci/python:3.8.4
    steps:
      - checkout
      - run:
          name: create environment to run code analyze
          command: |
            # require virtural environ 
            make setup
      - run:
          name: install dependencies
          command: |
            # install deps
            make install
      - run:
          name: run code lints
          command: |
            # format the source code 
            make lint
      - save_cache:
          paths:
            - ".venv"
          key: deps-Pipfile.lock
    
  coverage_tests:
    docker:
      - image: circleci/python:3.8.4
      - image: circleci/postgres:9.6.16
        environment:
          POSTGRES_USERNAME: ${POSTGRES_USERNAME}
          POSRGRES_PASSWORD: ${POSTGRES_PASSWORD}
          POSTGRES_PORT: 5432
    environment:
      POSTGRES_HOSTNAME: localhost   
    steps:
      - checkout
      - restore_cache:
          keys: 
            - deps-Pipfile.lock
      - run:
          name: Install dependencies
          command: |
            sudo apt update 
            sudo apt-get install -y postgresql-client --fix-missing
            # make install    
      - run:
          name: run local database migrations tests           
          command: |
            export FLASK_APP=${OPENHCS_APP}
            pipenv run flask populate --tables=all; 
            psql -h $POSTGRES_HOSTNAME -U $POSTGRES_USERNAME -d postgres -w -c "\l"
            psql -h $POSTGRES_HOSTNAME -U $POSTGRES_USERNAME -d postgres -w -c "\dt"
            # make migrations
      - run:
          name: run code coverage tests 
          command: |
            # pass IF coverage > 70%
            make test

  
  make_migrations:
    docker:
      - image: circleci/python:3.8.4
    steps:
      - checkout
      - restore_cache:
          keys: 
            - deps-Pipfile.lock
      - run:
          name: prepare the required variables for migrations 
          command: |
            cat > ./openhcs/.env \<< EOF 
            FLASK_ENV=production
            PSQL_DB_PROFILES=${PSQL_DB_PROFILES}
            PSQL_DB_SCHEDULES=${PSQL_DB_SCHEDULES}
            PSQL_DB_SUBSCRIBERS=${PSQL_DB_SUBSCRIBERS}
            PSQL_DB_BOOKING=${PSQL_DB_BOOKING}
            PSQL_HOSTNAME=${PSQL_HOSTNAME}
            PSQL_PASSWORD=${PSQL_PASSWORD}
            PSQL_USERNAME=${PSQL_USERNAME}
            EOF
            
      - run:
          name: run migrations
          command: |
            # execute flask-migrate
            export FLASK_APP=${OPENHCS_APP}
            make migrations

  build_docker_image:
    description: build the docker image from code
    machine: 
      image: ubuntu-2004:202107-02
    environment:
      OPENHCS_IMAGE_TAG: "${DOCKER_ID}/openhcs:latest"
    steps:
      - checkout
      - run:
          name: login to docker hub
          command: docker login --username ${DOCKER_ID} --password ${DOCKER_PASSWORD}
      - run:
          name: build the openhcs docker image
          command: |
            docker build . -t openhcs:latest
            export docker_path=${DOCKER_ID}/openhcs:latest
            docker tag openhcs:latest $docker_path
      - run:
          name: push openhcs image to docker hub
          command: |
            export docker_path=${DOCKER_ID}/openhcs:latest
            docker push $docker_path

  create_cluster_infrastructure:
    description: provision the cluster infrastructue 
    docker: 
      - image: cimg/base:stable
      # - image: amazon/aws-cli
    environment:
      CLUSTER_IAC_STACK_NAME: openhcs-iacode
    steps:
      - checkout
      - setup_awscli
      - run:
          name: create the network infrastructure
          working_directory: ".circleci/deployment/IaC"
          no_output_timeout: 20m
          command: |
            aws cloudformation deploy --stack-name ${CLUSTER_IAC_STACK_NAME} \
            --template-file clusterIaC.yml --region "${AWS_DEFAULT_REGION}" \
            --capabilities "CAPABILITY_IAM" "CAPABILITY_NAMED_IAM" \
            --profile default 
            
      # - cache_handle:
      #     operation: 'PUT'
      #     key: "CLUSTER_IAC_STACKNAME"
      #     value: ${CLUSTER_IAC_STACK_NAME}
      - destroy_environ:
          awsConfigStatus: "yes"
          clusteNetworkStackName: ${CLUSTER_IAC_STACK_NAME} 
          clusterCoreStackName: ''  

  create_cluster_core:
    description: create cluster control plane and workload node 
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - setup_awscli
      - aws-eks/install-eksctl
      - run:
          name: create cluster and managed node groups
          working_directory: ".circleci/deployment/IaC"
          no_output_timeout: 20m
          command: |
            aws cloudformation deploy --stack-name ${CLUSTER_STACK_NAME} \
            --template-file clusterCore.yml --region ${AWS_DEFAULT_REGION} \
            --capabilities "CAPABILITY_IAM" "CAPABILITY_NAMED_IAM" \
            --parameter-overrides ClusterIaCStackName="${CLUSTER_IAC_STACK_NAME}" --profile default 
            
      - run:
          name: enable cluster logging types 
          command: |
            eksctl utils update-cluster-logging --cluster $CLUSTER_NAME  --enable-types=all --approve
      # - cache_handle:
      #     operation: 'PUT'
      #     key: "CLUSTER_STACK_NAME"
      #     value: $CLUSTER_STACK_NAME
      - destroy_environ:
          awsConfigStatus: "yes"
          clusteNetworkStackName: $CLUSTER_IAC_STACK_NAME
          clusterCoreStackName: $CLUSTER_STACK_NAME

  configure_cluster_core:
    description: configure cluster kubernetes 
    docker:
      - image: circleci/python:3.8.4
    environment:
      GREEN_SERVER_PORT: 80
      # To remove
    steps:
      - checkout
      - setup_awscli
      - kubernetes/install-kubectl:
          kubectl-version: latest
      - aws-eks/install-eksctl
      - aws-eks/update-kubeconfig-with-authenticator: 
          aws-region: ${AWS_DEFAULT_REGION}
          cluster-name: ${CLUSTER_NAME}
      - install_envsubs
      - run:
          name: test kubernetes config file 
          command: |
            SVCS=$(kubectl  get services -n kube-system -o json )
            
            # Abort deployment if empty 
            if [[ -n $( echo "$SVCS" | grep "kube-system" ) ]]; then 
              echo "Cofigured Successfully";
              ls ~/.kube
            else
              echo "$SVCS"
              exit 1;
            fi;
      - run:
          name: create services for app deployment
          working_directory: ".circleci/deployment/K8s"  
          command: |
            # create services
            chmod +x ./xbin/services-init.sh
            ./xbin/services-init.sh $GREEN_SERVER_PORT ./services.yml;

            # kubectl wait --for=condition=available --timeout=120s services -n default -l 'environ in (production, staging)' ;
      # - run:
      #     name: create alb ingresses
      #     working_directory: ".circleci/deployment/K8s"
      #     command: |
      #       kubectl apply -f ingresses.yml
      #       sleep 10s
      #       kubectl describe ingresses -n default
      - run:
          name: create secretes 
          working_directory: ".circleci/deployment/K8s"
          command: |          
            # create secrets
            chmod +x ./xbin/secrets-init.sh
            ./xbin/secrets-init.sh ./secrets.yml

            kubectl get secrets -n default
      # persist the kubeconfig file
      - run:
          name: create config maps 
          working_directory: ".circleci/deployment/K8s"
          command: |
            # create configmaps
            chmod +x ./xbin/configs-init.sh
            ./xbin/configs-init.sh ./configmaps.yml

      - persist_to_workspace:
          root: ~/
          paths:
            - ".kube"
      - destroy_environ:
          awsConfigStatus: "yes"
          clusteNetworkStackName: $CLUSTER_IAC_STACK_NAME
          clusterCoreStackName: $CLUSTER_STACK_NAME
    
  deploy_staging_green_k8s:
    description: >- 
      Deploy API server kubernetes in staging environment at green context.
    docker:
      - image: circleci/python:3.8.4
    environment:
      ENVIRON: staging     # environ for the deployment
      SERVER_PORT: 80      # web server port number
      VERSION: 1          # deployment version
    steps:
      - checkout
      - attach_workspace:
          at: ~/
      - kubernetes/install-kubectl:
          kubectl-version: latest 
      - install_envsubs
      - setup_awscli
      # - aws-eks/install-eksctl
      # - run:
      #     name: create kubeconfig
      #     command: |
      #       eksctl utils write-kubeconfig --cluster $CLUSTER_NAME --region $AWS_DEFAULT_REGION
      - run:
          name: make staging deployment
          working_directory: ".circleci/deployment/K8s"
          command: |
            OPENHCS_IMAGE="${DOCKER_ID}/openhcs:latest"   # docker image
            chmod +x xbin/deploy-init.sh
            # execute the deployment of app in the staging environment
            ./xbin/deploy-init.sh $ENVIRON $SERVER_PORT $VERSION $OPENHCS_IMAGE "./deployments.yml"
            
            kubectl get deployments -n default -l tier=backend,environ=$ENVIRON,context=green;            
      - run: 
          name: make smoke test on staging green deployment 
          working_directory: ".circleci/deployment/K8s"
          command: |
            # get the url of staging green app
            kubectl wait --for=condition=Ready=true --timeout=120s pods -l environ="staging",app="openhcs"
            export HOSTNAME=$(kubectl get configmaps -n default -l environ=staging,app=openhcs -o jsonpath="{.items[].data.SERVER_HOSTNAME}")
             
            URL="http://${HOSTNAME}:$SERVER_PORT"

            echo "$URL"
          
            until [ -z $( curl -sS "$URL" | grep "ok" ) ]; do
              echo "No response"
              sleep 3s
            done;

            echo -e "Staging accessible from: $URL";


      - destroy_environ:
            awsConfigStatus: "yes"
            clusteNetworkStackName: ${CLUSTER_IAC_STACK_NAME} 
            clusterCoreStackName: ${CLUSTER_STACK_NAME}
     
  deploy_production_blue_k8s:
    description: >-
      Depeloy in production production blue context (IF pass smoke test) and make smoke tests.
    docker:
      - image: circleci/python:3.8.4
    environment:
      SERVER_PORT: 443
      ENVIRON: production
    steps:
      - checkout
      - attach_workspace:
          at: ~/
      - kubernetes/install-kubectl:
          kubectl-version: latest 
      - install_envsubs
      - setup_awscli
      # - aws-eks/install-eksctl
      # - run:
      #     name: create kubeconfig
      #     command: |
      #       eksctl utils write-kubeconfig --cluster $CLUSTER_NAME --region $AWS_DEFAULT_REGION
      - run:
          name: deploy the app
          working_directory: ".circleci/deployment/K8s"
          command: |
            OPENHCS_IMAGE="${DOCKER_ID}/openhcs:latest"   # docker image

            # retrieve the staging deployment version
            VERSION=$( kubectl  get deployments -n default -l environ='staging',tier=backend,context=green -o jsonpath="{.items[0].metadata.labels.version}");
            
            chmod +x ./xbin/deploy-init.sh
            ./xbin/deploy-init.sh $ENVIRON $SERVER_PORT $VERSION $OPENHCS_IMAGE "./deployments.yml" ;
            
            kubectl get deployments -n default;

      - run:
          name: meke in production smoke tests 
          command: |
            # get the url of in production blue app
            kubectl wait --for=condition=Ready=true --timeout=120s pods -l environ="production",app="openhcs";
            export HOSTNAME=$(kubectl get configmaps -n default -l environ=production,app=openhcs -o jsonpath="{.items[].data.SERVER_HOSTNAME}")
            
            URL="http://${HOSTNAME}:$SERVER_PORT"        

            STAGING=$(kubectl get deployments -l environ='staging',context='green' -o jsonpath="{.items[0].metadata.labels.name}")

            echo "$URL"

            # check in production app status is ok
            until [ -z $( curl -sS "$URL" | grep "ok" ) ]; do
              echo "No response"
              sleep 3s
            done;

            if [[ $? == 0  ]]; then 
              echo -e "Production accessible from: $URL";
            else
              # eliminate in production app if status is NOT ok, and exit with failure
              kubectl delete deployments/${PRO_OPENHCS_DPY} -n default;
              exit 1
            fi;
      - destroy_environ:
          awsConfigStatus: "yes"
          clusteNetworkStackName: ${CLUSTER_IAC_STACK_NAME} 
          clusterCoreStackName: ${CLUSTER_STACK_NAME}

  clean_up_deployment_stacks:
    docker:
      - image: circleci/python:3.8.4
    steps:
      - checkout
      - setup_awscli
      - attach_workspace:
          at: ~/
      - kubernetes/install-kubectl:
          kubectl-version: latest
      - run:
          name: Eliminate staging deploymemt
          command: |
            # eliminate the in staging deployment
              kubectl delete deployments/${STAG_OPENHCS_DPY} --namespace default
              kubectl wait --for=delete --timeout=60s pods -l environ="staging",app="openhcs";
              kubectl get deployments;
      - run:
          name: cleanup testing envirion 
          command: |
            aws cloudformation delete-stack --stack-name ${CLUSTER_STACK_NAME} --region "${AWS_DEFAULT_REGION}";
      - delete_network_infra_stack 
          
 
workflows:
  OpenHeathCare CICD:
    jobs:
      - build_app
      - coverage_tests:
          context: THEOPENHCS
          requires:
            - "build_app"
      - review_codebase:
          type: approval
          requires:
            - coverage_tests
      - make_migrations:
          context: THEOPENHCS
          requires:
            - "coverage_tests"
            - "review_codebase"
          filters:
            branches:
              only: [main]
      - build_docker_image:
          context: THEOPENHCS
          filters:
            branches:
              only: [main]
          requires:
            - coverage_tests
            - make_migrations
      - review_built_image:
          requires: [build_docker_image]
          type: approval
      
      - create_cluster_infrastructure:
          context: THEOPENHCS
          pre-steps:
            - run:
                name: Notify administrator
                command: |
                  echo  "Send notification from here"
          requires:
            - review_built_image
            - build_docker_image
          filters:
            branches:
              only: [main]

      - create_cluster_core:
          context: THEOPENHCS
          requires:
            - create_cluster_infrastructure

      - configure_cluster_core:
          context: THEOPENHCS
          requires:
            - "create_cluster_core"
          filters:
            branches:
              only: [main]
          post-steps:
            - run:
                name: Notify administrator
                command: |
                  echo "Send notification from here"
      - deploy_staging_green_k8s:
          context: THEOPENHCS
          requires:
            - "configure_cluster_core"

      - deploy_production_blue_k8s:
          context: THEOPENHCS
          requires:
            - "deploy_staging_green_k8s"
      
      - hold:
          type: approval
          requires:
            - "deploy_production_blue_k8s"
      - clean_up_deployment_stacks:
          context: THEOPENHCS
          requires:
            - "hold"
          pre-steps:
            - run:
                name: notify_product_engineer
                command: echo "Deployment complete"